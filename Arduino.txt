#include <WiFi.h>
#include <WiFiMulti.h>
#include <HTTPClient.h>
#include <ArduinoWebsockets.h>
#include <ArduinoJson.h>

// WiFi Configuration
const char* ssid = "Sasi";
const char* password = "toolkitt";
const char* websocketURL = "10.235.124.11";  // Your computer's IP address
const int websocketPort = 8080;

// Backend API Configuration (for triggering app actions)
const char* backendURL = "http://10.235.124.11:10000";  // Your backend server

WiFiMulti wifiMulti;
using namespace websockets;
WebsocketsClient client;

// Hardware Configuration
const int buttonPin = 4;
const int ledPin = 2;  // Built-in LED for status
const int micPin = 1;  // MAX9814 OUT connected to GPIO1

// Audio Configuration
const int sampleRate = 16000;
const int bufferSize = 512;
int16_t audioBuffer[bufferSize];
bool isRecording = false;
bool isConnected = false;
int bufferIndex = 0;

// State Management
bool lastButtonState = HIGH;
unsigned long lastPingTime = 0;
const unsigned long pingInterval = 30000; // Ping every 30 seconds
unsigned long lastReconnectAttempt = 0;
const unsigned long reconnectInterval = 5000; // Try reconnect every 5 seconds

void setup() {
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("üé§ ESP32 Storytelling Toolkit Microphone Client");
  Serial.println("============================================");
  
  // Initialize hardware
  pinMode(buttonPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);
  
  // Configure ADC for MAX9814 microphone
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);
  
  // Connect to WiFi with timeout
  connectToWiFi();
  
  // Setup WebSocket connection
  setupWebSocket();
}

void loop() {
  // Feed watchdog
  yield();
  
  // Maintain WebSocket connection
  if (isConnected) {
    client.poll();
  } else {
    attemptReconnection();
  }
  
  // Handle button press
  handleButtonPress();
  
  // Send periodic ping to maintain connection and identify as ESP32
  sendPeriodicPing();
  
  // Handle audio recording
  if (isRecording && isConnected) {
    sampleAndStreamAudio();
  }
  
  // Non-blocking delay
  delay(10);
}

void connectToWiFi() {
  WiFi.mode(WIFI_STA);
  wifiMulti.addAP(ssid, password);
  
  Serial.print("üîå Connecting to Wi-Fi");
  unsigned long wifiStartTime = millis();
  
  // Non-blocking WiFi connection with timeout
  while (wifiMulti.run() != WL_CONNECTED && (millis() - wifiStartTime) < 20000) {
    Serial.print(".");
    digitalWrite(ledPin, !digitalRead(ledPin)); // Blink LED
    delay(500);
    yield(); // Feed watchdog
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println(" ‚úÖ Connected!");
    Serial.printf("üìç IP Address: %s\n", WiFi.localIP().toString().c_str());
    digitalWrite(ledPin, HIGH);
  } else {
    Serial.println(" ‚ùå Failed to connect to WiFi!");
    digitalWrite(ledPin, LOW);
  }
}

void setupWebSocket() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå No WiFi connection for WebSocket");
    return;
  }
  
  // Set up WebSocket event handlers
  client.onMessage([&](WebsocketsMessage message) {
    handleWebSocketMessage(message);
  });

  client.onEvent([&](WebsocketsEvent event, String data) {
    handleWebSocketEvent(event, data);
  });

  // Attempt connection
  Serial.printf("üîå Connecting to WebSocket: %s:%d\n", websocketURL, websocketPort);
  bool connected = client.connect(websocketURL, websocketPort, "/");
  
  if (connected) {
    Serial.println("‚úÖ WebSocket connected successfully");
    isConnected = true;
    digitalWrite(ledPin, HIGH);
    
    // Send initial ping to identify as ESP32
    sendDeviceIdentification();
  } else {
    Serial.println("‚ùå WebSocket connection failed");
    isConnected = false;
    digitalWrite(ledPin, LOW);
  }
}

void handleWebSocketMessage(WebsocketsMessage message) {
  Serial.printf("üì• Received: %s\n", message.data().c_str());
  
  // Parse JSON response
  DynamicJsonDocument doc(1024);
  DeserializationError error = deserializeJson(doc, message.data());
  
  if (error) {
    Serial.printf("‚ùå JSON parse error: %s\n", error.c_str());
    return;
  }
  
  String action = doc["action"];
  
  if (action == "transcript") {
    String transcript = doc["text"];
    String device = doc["device"];
    float duration = doc["duration"];
    
    Serial.println("‚úÖ Transcription received!");
    Serial.printf("   üìù Text: %s\n", transcript.c_str());
    Serial.printf("   üé§ Device: %s\n", device.c_str());
    Serial.printf("   ‚è±Ô∏è Duration: %.1fs\n", duration);
    
    // Stop recording
    stopRecording();
    
    // Send transcript to backend for processing
    sendTranscriptToBackend(transcript);
    
  } else if (action == "pong") {
    Serial.println("üèì Received pong from server");
  } else if (action == "error") {
    String errorMsg = doc["message"];
    Serial.printf("‚ùå Server error: %s\n", errorMsg.c_str());
    stopRecording();
  }
}

void handleWebSocketEvent(WebsocketsEvent event, String data) {
  switch (event) {
    case WebsocketsEvent::ConnectionOpened:
      Serial.println("üîó WebSocket connection opened");
      isConnected = true;
      digitalWrite(ledPin, HIGH);
      sendDeviceIdentification();
      break;
      
    case WebsocketsEvent::ConnectionClosed:
      Serial.println("‚ùå WebSocket connection closed");
      isConnected = false;
      digitalWrite(ledPin, LOW);
      if (isRecording) stopRecording();
      break;
      
    case WebsocketsEvent::GotPing:
      Serial.println("üèì Received ping from server");
      break;
      
    default:
      break;
  }
}

void handleButtonPress() {
  bool currentButtonState = digitalRead(buttonPin);
  
  if (lastButtonState == HIGH && currentButtonState == LOW && isConnected) {
    Serial.println("üü¢ Button pressed!");
    
    if (!isRecording) {
      startRecording();
    } else {
      stopRecording();
    }
    
    delay(200); // Debounce
  }
  
  lastButtonState = currentButtonState;
}

void startRecording() {
  if (!isConnected) {
    Serial.println("‚ùå Cannot start recording - not connected");
    return;
  }
  
  Serial.println("üé§ Starting audio recording...");
  isRecording = true;
  bufferIndex = 0;
  
  // Send start recording message
  DynamicJsonDocument doc(256);
  doc["action"] = "start_recording";
  doc["device"] = "ESP32";
  doc["sample_rate"] = sampleRate;
  doc["format"] = "pcm16";
  doc["message"] = "ESP32 MAX9814 microphone recording started";
  
  String jsonString;
  serializeJson(doc, jsonString);
  client.send(jsonString);
  
  Serial.println("üì§ Sent start recording message");
  
  // Blink LED to indicate recording start
  for (int i = 0; i < 6; i++) {
    digitalWrite(ledPin, !digitalRead(ledPin));
    delay(100);
  }
  digitalWrite(ledPin, LOW); // LED off during recording
}

void stopRecording() {
  if (!isRecording) return;
  
  Serial.println("‚èπÔ∏è Stopping audio recording...");
  isRecording = false;
  digitalWrite(ledPin, isConnected ? HIGH : LOW);
  
  // Send stop recording message
  DynamicJsonDocument doc(256);
  doc["action"] = "stop_recording";
  doc["device"] = "ESP32";
  doc["message"] = "ESP32 recording completed";
  
  String jsonString;
  serializeJson(doc, jsonString);
  client.send(jsonString);
  
  Serial.println("üì§ Sent stop recording message");
}

void sampleAndStreamAudio() {
  // Sample audio into buffer
  while (bufferIndex < bufferSize && isRecording) {
    int rawValue = analogRead(micPin);
    int16_t sample = (rawValue - 2048) * 8; // Convert to signed 16-bit
    
    audioBuffer[bufferIndex] = sample;
    bufferIndex++;
    
    // Control sampling rate (approximately 16kHz)
    delayMicroseconds(25); // Fine-tuned timing for optimal sampling
    
    // Feed watchdog during long operations
    if (bufferIndex % 100 == 0) {
      yield();
    }
  }
  
  // Send buffer when full
  if (bufferIndex >= bufferSize) {
    bool sent = client.sendBinary((const char*)audioBuffer, bufferSize * sizeof(int16_t));
    bufferIndex = 0;
    
    // Debug output
    static int chunkCount = 0;
    chunkCount++;
    if (chunkCount % 10 == 0) { // Every 10th chunk
      Serial.printf("üì§ Sent audio chunk %d (%d bytes) - Status: %s\n", 
                   chunkCount, bufferSize * sizeof(int16_t), sent ? "OK" : "FAILED");
    }
  }
}

void sendDeviceIdentification() {
  if (!isConnected) return;
  
  DynamicJsonDocument doc(512);
  doc["action"] = "ping";
  doc["device"] = "ESP32-S3";
  doc["microphone"] = "MAX9814";
  doc["message"] = "ESP32 Storytelling Toolkit Client";
  doc["version"] = "1.0";
  doc["capabilities"] = "audio_recording,button_trigger,led_status";
  doc["sample_rate"] = sampleRate;
  doc["timestamp"] = millis();
  
  String jsonString;
  serializeJson(doc, jsonString);
  client.send(jsonString);
  
  Serial.println("üèì Sent device identification");
}

void sendPeriodicPing() {
  if (millis() - lastPingTime > pingInterval && isConnected) {
    sendDeviceIdentification();
    lastPingTime = millis();
  }
}

void attemptReconnection() {
  if (millis() - lastReconnectAttempt > reconnectInterval) {
    Serial.println("üîÑ Attempting to reconnect...");
    setupWebSocket();
    lastReconnectAttempt = millis();
  }
}

void sendTranscriptToBackend(String transcript) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå No WiFi for backend request");
    return;
  }
  
  Serial.println("üì§ Sending transcript to backend for processing...");
  
  HTTPClient http;
  String url = String(backendURL) + "/trigger-button";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  
  // Create JSON payload with transcript
  DynamicJsonDocument doc(512);
  doc["source"] = "ESP32";
  doc["transcript"] = transcript;
  doc["device"] = "ESP32-MAX9814";
  doc["timestamp"] = millis();
  
  String payload;
  serializeJson(doc, payload);
  
  int httpResponseCode = http.POST(payload);
  
  if (httpResponseCode > 0) {
    String response = http.getString();
    Serial.printf("‚úÖ Backend response (%d): %s\n", httpResponseCode, response.c_str());
  } else {
    Serial.printf("‚ùå Backend request failed: %s\n", http.errorToString(httpResponseCode).c_str());
  }
  
  http.end();
}
